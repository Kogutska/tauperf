#!/usr/bin/env python
import os
import shutil

from rootpy.io import root_open
from rootpy.tree import TreeModel, FloatCol

import logging
from multiprocessing import Process
import ROOT
import array
    
from tauperf.categories import (Category_1P_HLT, Category_3P_HLT,
                                Category_1P, Category_3P)

log = logging.getLogger('apply-bdt-weights-from-xml')


def get_readers(category):

    reader_odd = ROOT.TMVA.Reader()
    reader_even = ROOT.TMVA.Reader()
    if 'hlt' in category.name:
        prefix = 'hlt_'
    else:
        prefix = 'off_'

    dummy_v = array.array('f', [0.])
    for f in category.features_pileup_corrected:
        reader_odd.AddVariable(prefix + f, dummy_v)
        reader_even.AddVariable(prefix +f, dummy_v)

    reader_odd.BookMVA(
        'BDT', 'weights/{0}_odd_BDT_{0}_odd.weights.xml'.format(
            category.name))
    reader_even.BookMVA(
        'BDT', 'weights/{0}_even_BDT_{0}_even.weights.xml'.format(
            category.name))

    return reader_odd, reader_even


def evaluate_single_bdt(reader, feats, tree):
    feats = vector('double')()
    for feat in feats:
        vals.push_back(getattr(tree, feat))
    return reader.GetMvaValue(vals)

def evaluate_bdt(tree, readers, feats):
    if tree.hlt_tau.ntracks == 1:
        if tree.eventnumber % 2 == 0:
            return evaluate_single_bdt(
                readers['1p_even'], feats['1p'], tree)
        else:
            return evaluate_single_bdt(
                readers['1p_odd'], feats['1p'], tree)
    elif tree.hlt_tau.ntracks > 1:
        if tree.eventnumber % 2 == 0:
            return evaluate_single_bdt(
                readers['mp_even'], feats['mp'], tree)
        else:
            return evaluate_single_bdt(
                readers['mp_odd'], feats['mp'], tree)
    else:
        return -9999.

def evaluate_score(event, tau, readers, category):
    
    feats = ROOT.vector('double')()
    for f in category.features_pileup_corrected:
        feats.push_back(getattr(tau, f))
    if event.eventnumber % 2 != 0:
        return readers[0].EvaluateMVA(feats, 'BDT')
    else:
        return readers[1].EvaluateMVA(feats, 'BDT')

class Model(TreeModel):
    hlt_bdt_score_off_training_dev = FloatCol()
    hlt_bdt_score_hlt_training_dev = FloatCol()
    off_bdt_score_dev = FloatCol()

def add_bdt_scores(tree):
    tree.create_buffer()
    tree.set_buffer(Model(), create_branches=True)
    branches = [
        tree.GetBranch('hlt_bdt_score_off_training_dev'),
        tree.GetBranch('hlt_bdt_score_hlt_training_dev'),
        tree.GetBranch('off_bdt_score_dev'),
        ]

    readers_1p = get_readers(Category_1P)
    readers_3p = get_readers(Category_3P)

    readers_1p_hlt = get_readers(Category_1P_HLT)
    readers_3p_hlt = get_readers(Category_3P_HLT)

    tree.define_object('hlt_tau', prefix='hlt_')
    tree.define_object('off_tau', prefix='off_')

    for event in tree:
        
        tau = event.off_tau
        hlt_tau = event.hlt_tau

        # offline
        if tau.ntracks == 1:
            event.off_bdt_score_dev = evaluate_score(
                event, tau, readers_1p, Category_1P)
        elif tau.ntracks > 1: 
            event.off_bdt_score_dev = evaluate_score(
                event, tau, readers_3p, Category_3P)
        else:
            event.off_bdt_score_dev = -9999

        # hlt
        if hlt_tau.ntracks == 1:
            event.hlt_bdt_score_off_training_dev = evaluate_score(
                event, hlt_tau, readers_1p, Category_1P)
            event.hlt_bdt_score_hlt_training_dev = evaluate_score(
                event, hlt_tau, readers_1p_hlt, Category_1P_HLT)
        elif hlt_tau.ntracks > 1: 
            event.hlt_bdt_score_off_training_dev = evaluate_score(
                event, hlt_tau, readers_3p, Category_3P)
            event.hlt_bdt_score_hlt_training_dev = evaluate_score(
                event, hlt_tau, readers_3p_hlt, Category_3P_HLT)
        else:
            event.hlt_bdt_score_hlt_training_dev = -9999
            event.hlt_bdt_score_off_training_dev = -9999



        for branch in branches:
            branch.Fill()
        
    tree.SetEntries(-1)

class Job(Process):
    def __init__(self, filename):
        super(Job, self).__init__()
        self.filename = filename

    def run(self):
        filename = self.filename
        path, name = os.path.split(filename)
        # copy to new file
        output = os.path.join(path, 'scored.' + name)
        if os.path.exists(output):
            return 
        log.info("copying {0} to {1} ...".format(filename, output))
        shutil.copy(filename, output)
        with root_open(output, 'UPDATE') as file:
            tree = file.tau
            if 'hlt_bdt_score_off_training_dev' in tree:
                log.info("scores already exist in {0} ...".format(output))
                return
            log.info("adding bdt scores to {0} ...".format(output))
            add_bdt_scores(tree)
            tree.Write(tree.name, ROOT.TObject.kOverwrite)


if __name__ == '__main__':
    from rootpy.extern.argparse import ArgumentParser

    parser = ArgumentParser()
    parser.add_argument('files', nargs='+')
    args = parser.parse_args()

    from tauperf.parallel import run_pool
    jobs = [Job(f) for f in args.files]
    run_pool(jobs, n_jobs=-1)


